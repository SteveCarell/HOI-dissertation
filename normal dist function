THRESH <<- 1e-6


#### model ####
LV_multispecies_competition <- function(t, x, parameters) {
  
  with(as.list(parameters), {
    
    # zero out species below the threshold    
    x[x<THRESH] <- 0
    
    #add saturated functions to prevent infinite growing
    pairwise_effects <- A %*% x
    saturated_pairwise <- pairwise_effects / (1 + h * abs(pairwise_effects))
    # Lotka-Volterra in matrix notation
    dxdt <- r*x*(1 - saturated_pairwise)
    
    # equivalent to the mathematical equation:
    # dxi/dt <- ri*xi - aii*xi^2 - sum(a_ij * xi * xj)
    
    # return rate of change
    return(list(dxdt))
    
  })
  
}

##HOI来咯
HOI <- function(t, x, parameters){
  with(as.list(c(x, parameters)), {
    Bm <- A
    for (i in 1:nrow(A)){
      x_combinations <- B[i,,] %*% x
      #add saturated functions to prevent infinite growing
      saturated_functions <- x_combinations / (1 + h * abs(x_combinations))
      Bm[i,] <- saturated_functions
    }
    x[x < THRESH] <- 0
    x[x > 1/THRESH] <- 1/THRESH
    dxdt <- x * (r - (A + Bm) %*% x)
    return(list(dxdt))
  })
}



#generate a tensor B matrix giving the HOIs
get_B_normal <- function(n, mean = 0, sd = 1, B_diag = 0){
  #change to the normal distribution
  B <- round(array(rnorm(n * n * n, mean = mean, sd = sd), c(n, n, n)), 2)
  for (i in 1:n){
    # this zeros out effects of a species on itself, thus
    # only allowing HOIs among three unique species
    for (j in 1:n){
      if (i == j){
        B[i,j,] <- 0
        B[i,,j] <- 0
      }
    }
    # this zeros out effects when the two competitors are the same,
    diag(B[i,,]) <- 0
    # adds in a cubic self-regulation term
    B[i,i,i] <- B_diag
    # this ensures the matrix is symmetric with respect to the competitors,
    # ie.,g the xjxk is equal to xkxj
    B[i,,] <- (B[i, ,] + t(B[i,,])) / 2
  }
  
  
  return(B)
}
